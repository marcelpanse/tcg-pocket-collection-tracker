import{T as w,l as h,p as y,e as l,U as _,z as f,A as x}from"./index-Dubx0UN8.js";import{i as u}from"./i18n-vendor-B8-LMkwa.js";function C(n,o){if(n.length===0)return o.length;if(o.length===0)return n.length;let r=Array(n.length+1).fill(0).map((e,t)=>t),a=Array(n.length+1);for(let e=1;e<=o.length;e++){a[0]=e;for(let t=1;t<=n.length;t++){const i=n[t-1]===o[e-1]?0:1;a[t]=Math.min(r[t]+1,a[t-1]+1,r[t-1]+i)}[r,a]=[a,r]}return r[n.length]}const L=["all",...l],N=["expansion-newest","recent"],k=_,O=["all","missing","registered"],b=["all","wanted","extra"];function B(n,o,r){let a=w;if(n.deckbuildingMode&&(a=a.filter(e=>e.internal_id===e.alternate_versions[0])),n.expansion!==void 0&&n.expansion!=="all"&&(a=a.filter(e=>e.expansion===n.expansion)),n.expansion!==void 0&&n.pack!==void 0&&n.pack!=="all"&&(a=a.filter(e=>e.pack===n.pack||e.pack==="everypack")),n.ownership!==void 0&&n.ownership!=="all"&&(a=a.filter(e=>n.ownership==="missing"?!e.collected:e.collected)),n.trading!==void 0&&n.trading!=="all"){if(!r)throw new Error("Cannot filter by trading status without trading settings");const e=new Set(n.trading==="wanted"?f(o,r):x(o,r));a=a.filter(t=>e.has(t.internal_id))}if(n.rarity!==void 0&&n.rarity.length>0){const e=n.rarity;a=a.filter(t=>e.includes(t.rarity))}if(n.cardType!==void 0&&n.cardType.length>0){const e=n.cardType;a=a.filter(t=>t.card_type.toLowerCase()==="trainer"?e.includes("trainer"):e.includes(t.energy))}if(n.search){const e=n.search.toLowerCase(),t=2;a=a.filter(i=>{const d=h(i,u.language).toLowerCase();let s=!1;n.allTextSearch&&(s=i.ability&&(i.ability.name.toLowerCase().includes(e)||i.ability.effect.toLowerCase().includes(e))||i.attacks.some(c=>c.name?.toLowerCase().includes(e)||c.effect?.toLowerCase()!=="no effect"&&c.effect?.toLowerCase()?.includes(e)));const p=d.includes(e),m=C(d,e)<=t,g=i.card_id.toLowerCase().includes(e);return s||p||m||g})}for(const e of a){n.deckbuildingMode?e.amount_owned=e.alternate_versions.reduce((i,d)=>{const s=y(d);return i+(o.get(s?.internal_id||0)?.amount_owned??0)},0):e.amount_owned=o.get(e.internal_id)?.amount_owned??0;const t=o.get(e.internal_id);e.collected=t?.collection.includes(e.card_id)??!1,e.updated_at=t?.updated_at}if(n.minNumber!==void 0){const e=n.minNumber;a=a.filter(t=>(t.amount_owned??0)>=e)}if(n.maxNumber!==void 0&&n.maxNumber!=="âˆž"){const e=n.maxNumber;a=a.filter(t=>(t.amount_owned??0)<=e)}return n.sortBy!==void 0&&(n.sortBy==="recent"?a.sort((e,t)=>e.updated_at&&t.updated_at?new Date(t.updated_at).getTime()-new Date(e.updated_at).getTime():e.updated_at&&!t.updated_at?-1:1):n.sortBy==="expansion-newest"&&a.sort((e,t)=>e.expansion!==t.expansion?l.indexOf(e.expansion)-l.indexOf(t.expansion):e.card_id.localeCompare(t.card_id,u.language||"en",{numeric:!0}))),a}export{k as c,L as e,B as g,O as o,N as s,b as t};
