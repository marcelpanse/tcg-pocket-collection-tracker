import{r as y,o as F,X as k,a5 as L,a6 as R,x as S,v as z,U as D,T as W,ao as N}from"./index-CBMXlKxj.js";function w(i,l,s){let t=s.initialDeps??[],e,n=!0;function o(){var r,a,d;let c;s.key&&((r=s.debug)!=null&&r.call(s))&&(c=Date.now());const u=i();if(!(u.length!==t.length||u.some((g,f)=>t[f]!==g)))return e;t=u;let m;if(s.key&&((a=s.debug)!=null&&a.call(s))&&(m=Date.now()),e=l(...u),s.key&&((d=s.debug)!=null&&d.call(s))){const g=Math.round((Date.now()-c)*100)/100,f=Math.round((Date.now()-m)*100)/100,b=f/16,x=(p,C)=>{for(p=String(p);p.length<C;)p=" "+p;return p};console.info(`%câ± ${x(f,5)} /${x(g,5)} ms`,`
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0,Math.min(120-120*b,120))}deg 100% 31%);`,s?.key)}return s?.onChange&&!(n&&s.skipInitialOnChange)&&s.onChange(e),n=!1,e}return o.updateDeps=r=>{t=r},o}function E(i,l){if(i===void 0)throw new Error("Unexpected undefined");return i}const B=(i,l)=>Math.abs(i-l)<1.01,j=(i,l,s)=>{let t;return function(...e){i.clearTimeout(t),t=i.setTimeout(()=>l.apply(this,e),s)}},O=i=>{const{offsetWidth:l,offsetHeight:s}=i;return{width:l,height:s}},P=i=>i,V=i=>{const l=Math.max(i.startIndex-i.overscan,0),s=Math.min(i.endIndex+i.overscan,i.count-1),t=[];for(let e=l;e<=s;e++)t.push(e);return t},U=(i,l)=>{const s=i.scrollElement;if(!s)return;const t=i.targetWindow;if(!t)return;const e=o=>{const{width:r,height:a}=o;l({width:Math.round(r),height:Math.round(a)})};if(e(O(s)),!t.ResizeObserver)return()=>{};const n=new t.ResizeObserver(o=>{const r=()=>{const a=o[0];if(a?.borderBoxSize){const d=a.borderBoxSize[0];if(d){e({width:d.inlineSize,height:d.blockSize});return}}e(O(s))};i.options.useAnimationFrameWithResizeObserver?requestAnimationFrame(r):r()});return n.observe(s,{box:"border-box"}),()=>{n.unobserve(s)}},_={passive:!0},I=typeof window>"u"?!0:"onscrollend"in window,$=(i,l)=>{const s=i.scrollElement;if(!s)return;const t=i.targetWindow;if(!t)return;let e=0;const n=i.options.useScrollendEvent&&I?()=>{}:j(t,()=>{l(e,!1)},i.options.isScrollingResetDelay),o=c=>()=>{const{horizontal:u,isRtl:h}=i.options;e=u?s.scrollLeft*(h&&-1||1):s.scrollTop,n(),l(e,c)},r=o(!0),a=o(!1);a(),s.addEventListener("scroll",r,_);const d=i.options.useScrollendEvent&&I;return d&&s.addEventListener("scrollend",a,_),()=>{s.removeEventListener("scroll",r),d&&s.removeEventListener("scrollend",a)}},q=(i,l,s)=>{if(l?.borderBoxSize){const t=l.borderBoxSize[0];if(t)return Math.round(t[s.options.horizontal?"inlineSize":"blockSize"])}return i[s.options.horizontal?"offsetWidth":"offsetHeight"]},H=(i,{adjustments:l=0,behavior:s},t)=>{var e,n;const o=i+l;(n=(e=t.scrollElement)==null?void 0:e.scrollTo)==null||n.call(e,{[t.options.horizontal?"left":"top"]:o,behavior:s})};class K{constructor(l){this.unsubs=[],this.scrollElement=null,this.targetWindow=null,this.isScrolling=!1,this.measurementsCache=[],this.itemSizeCache=new Map,this.laneAssignments=new Map,this.pendingMeasuredCacheIndexes=[],this.prevLanes=void 0,this.lanesChangedFlag=!1,this.lanesSettling=!1,this.scrollRect=null,this.scrollOffset=null,this.scrollDirection=null,this.scrollAdjustments=0,this.elementsCache=new Map,this.observer=(()=>{let s=null;const t=()=>s||(!this.targetWindow||!this.targetWindow.ResizeObserver?null:s=new this.targetWindow.ResizeObserver(e=>{e.forEach(n=>{const o=()=>{this._measureElement(n.target,n)};this.options.useAnimationFrameWithResizeObserver?requestAnimationFrame(o):o()})}));return{disconnect:()=>{var e;(e=t())==null||e.disconnect(),s=null},observe:e=>{var n;return(n=t())==null?void 0:n.observe(e,{box:"border-box"})},unobserve:e=>{var n;return(n=t())==null?void 0:n.unobserve(e)}}})(),this.range=null,this.setOptions=s=>{Object.entries(s).forEach(([t,e])=>{typeof e>"u"&&delete s[t]}),this.options={debug:!1,initialOffset:0,overscan:1,paddingStart:0,paddingEnd:0,scrollPaddingStart:0,scrollPaddingEnd:0,horizontal:!1,getItemKey:P,rangeExtractor:V,onChange:()=>{},measureElement:q,initialRect:{width:0,height:0},scrollMargin:0,gap:0,indexAttribute:"data-index",initialMeasurementsCache:[],lanes:1,isScrollingResetDelay:150,enabled:!0,isRtl:!1,useScrollendEvent:!1,useAnimationFrameWithResizeObserver:!1,...s}},this.notify=s=>{var t,e;(e=(t=this.options).onChange)==null||e.call(t,this,s)},this.maybeNotify=w(()=>(this.calculateRange(),[this.isScrolling,this.range?this.range.startIndex:null,this.range?this.range.endIndex:null]),s=>{this.notify(s)},{key:!1,debug:()=>this.options.debug,initialDeps:[this.isScrolling,this.range?this.range.startIndex:null,this.range?this.range.endIndex:null]}),this.cleanup=()=>{this.unsubs.filter(Boolean).forEach(s=>s()),this.unsubs=[],this.observer.disconnect(),this.scrollElement=null,this.targetWindow=null},this._didMount=()=>()=>{this.cleanup()},this._willUpdate=()=>{var s;const t=this.options.enabled?this.options.getScrollElement():null;if(this.scrollElement!==t){if(this.cleanup(),!t){this.maybeNotify();return}this.scrollElement=t,this.scrollElement&&"ownerDocument"in this.scrollElement?this.targetWindow=this.scrollElement.ownerDocument.defaultView:this.targetWindow=((s=this.scrollElement)==null?void 0:s.window)??null,this.elementsCache.forEach(e=>{this.observer.observe(e)}),this._scrollToOffset(this.getScrollOffset(),{adjustments:void 0,behavior:void 0}),this.unsubs.push(this.options.observeElementRect(this,e=>{this.scrollRect=e,this.maybeNotify()})),this.unsubs.push(this.options.observeElementOffset(this,(e,n)=>{this.scrollAdjustments=0,this.scrollDirection=n?this.getScrollOffset()<e?"forward":"backward":null,this.scrollOffset=e,this.isScrolling=n,this.maybeNotify()}))}},this.getSize=()=>this.options.enabled?(this.scrollRect=this.scrollRect??this.options.initialRect,this.scrollRect[this.options.horizontal?"width":"height"]):(this.scrollRect=null,0),this.getScrollOffset=()=>this.options.enabled?(this.scrollOffset=this.scrollOffset??(typeof this.options.initialOffset=="function"?this.options.initialOffset():this.options.initialOffset),this.scrollOffset):(this.scrollOffset=null,0),this.getFurthestMeasurement=(s,t)=>{const e=new Map,n=new Map;for(let o=t-1;o>=0;o--){const r=s[o];if(e.has(r.lane))continue;const a=n.get(r.lane);if(a==null||r.end>a.end?n.set(r.lane,r):r.end<a.end&&e.set(r.lane,!0),e.size===this.options.lanes)break}return n.size===this.options.lanes?Array.from(n.values()).sort((o,r)=>o.end===r.end?o.index-r.index:o.end-r.end)[0]:void 0},this.getMeasurementOptions=w(()=>[this.options.count,this.options.paddingStart,this.options.scrollMargin,this.options.getItemKey,this.options.enabled,this.options.lanes],(s,t,e,n,o,r)=>(this.prevLanes!==void 0&&this.prevLanes!==r&&(this.lanesChangedFlag=!0),this.prevLanes=r,this.pendingMeasuredCacheIndexes=[],{count:s,paddingStart:t,scrollMargin:e,getItemKey:n,enabled:o,lanes:r}),{key:!1,skipInitialOnChange:!0,onChange:()=>{this.notify(this.isScrolling)}}),this.getMeasurements=w(()=>[this.getMeasurementOptions(),this.itemSizeCache],({count:s,paddingStart:t,scrollMargin:e,getItemKey:n,enabled:o,lanes:r},a)=>{if(!o)return this.measurementsCache=[],this.itemSizeCache.clear(),this.laneAssignments.clear(),[];if(this.laneAssignments.size>s)for(const h of this.laneAssignments.keys())h>=s&&this.laneAssignments.delete(h);this.lanesChangedFlag&&(this.lanesChangedFlag=!1,this.lanesSettling=!0,this.measurementsCache=[],this.itemSizeCache.clear(),this.laneAssignments.clear(),this.pendingMeasuredCacheIndexes=[]),this.measurementsCache.length===0&&(this.measurementsCache=this.options.initialMeasurementsCache,this.measurementsCache.forEach(h=>{this.itemSizeCache.set(h.key,h.size)}));const d=this.lanesSettling?0:this.pendingMeasuredCacheIndexes.length>0?Math.min(...this.pendingMeasuredCacheIndexes):0;this.pendingMeasuredCacheIndexes=[],this.lanesSettling&&this.measurementsCache.length===s&&(this.lanesSettling=!1);const c=this.measurementsCache.slice(0,d),u=new Array(r).fill(void 0);for(let h=0;h<d;h++){const m=c[h];m&&(u[m.lane]=h)}for(let h=d;h<s;h++){const m=n(h),g=this.laneAssignments.get(h);let f,b;if(g!==void 0&&this.options.lanes>1){f=g;const v=u[f],M=v!==void 0?c[v]:void 0;b=M?M.end+this.options.gap:t+e}else{const v=this.options.lanes===1?c[h-1]:this.getFurthestMeasurement(c,h);b=v?v.end+this.options.gap:t+e,f=v?v.lane:h%this.options.lanes,this.options.lanes>1&&this.laneAssignments.set(h,f)}const x=a.get(m),p=typeof x=="number"?x:this.options.estimateSize(h),C=b+p;c[h]={index:h,start:b,size:p,end:C,key:m,lane:f},u[f]=h}return this.measurementsCache=c,c},{key:!1,debug:()=>this.options.debug}),this.calculateRange=w(()=>[this.getMeasurements(),this.getSize(),this.getScrollOffset(),this.options.lanes],(s,t,e,n)=>this.range=s.length>0&&t>0?X({measurements:s,outerSize:t,scrollOffset:e,lanes:n}):null,{key:!1,debug:()=>this.options.debug}),this.getVirtualIndexes=w(()=>{let s=null,t=null;const e=this.calculateRange();return e&&(s=e.startIndex,t=e.endIndex),this.maybeNotify.updateDeps([this.isScrolling,s,t]),[this.options.rangeExtractor,this.options.overscan,this.options.count,s,t]},(s,t,e,n,o)=>n===null||o===null?[]:s({startIndex:n,endIndex:o,overscan:t,count:e}),{key:!1,debug:()=>this.options.debug}),this.indexFromElement=s=>{const t=this.options.indexAttribute,e=s.getAttribute(t);return e?parseInt(e,10):(console.warn(`Missing attribute name '${t}={index}' on measured element.`),-1)},this._measureElement=(s,t)=>{const e=this.indexFromElement(s),n=this.measurementsCache[e];if(!n)return;const o=n.key,r=this.elementsCache.get(o);r!==s&&(r&&this.observer.unobserve(r),this.observer.observe(s),this.elementsCache.set(o,s)),s.isConnected&&this.resizeItem(e,this.options.measureElement(s,t,this))},this.resizeItem=(s,t)=>{const e=this.measurementsCache[s];if(!e)return;const n=this.itemSizeCache.get(e.key)??e.size,o=t-n;o!==0&&((this.shouldAdjustScrollPositionOnItemSizeChange!==void 0?this.shouldAdjustScrollPositionOnItemSizeChange(e,o,this):e.start<this.getScrollOffset()+this.scrollAdjustments)&&this._scrollToOffset(this.getScrollOffset(),{adjustments:this.scrollAdjustments+=o,behavior:void 0}),this.pendingMeasuredCacheIndexes.push(e.index),this.itemSizeCache=new Map(this.itemSizeCache.set(e.key,t)),this.notify(!1))},this.measureElement=s=>{if(!s){this.elementsCache.forEach((t,e)=>{t.isConnected||(this.observer.unobserve(t),this.elementsCache.delete(e))});return}this._measureElement(s,void 0)},this.getVirtualItems=w(()=>[this.getVirtualIndexes(),this.getMeasurements()],(s,t)=>{const e=[];for(let n=0,o=s.length;n<o;n++){const r=s[n],a=t[r];e.push(a)}return e},{key:!1,debug:()=>this.options.debug}),this.getVirtualItemForOffset=s=>{const t=this.getMeasurements();if(t.length!==0)return E(t[T(0,t.length-1,e=>E(t[e]).start,s)])},this.getOffsetForAlignment=(s,t,e=0)=>{const n=this.getSize(),o=this.getScrollOffset();t==="auto"&&(t=s>=o+n?"end":"start"),t==="center"?s+=(e-n)/2:t==="end"&&(s-=n);const r=this.getTotalSize()+this.options.scrollMargin-n;return Math.max(Math.min(r,s),0)},this.getOffsetForIndex=(s,t="auto")=>{s=Math.max(0,Math.min(s,this.options.count-1));const e=this.measurementsCache[s];if(!e)return;const n=this.getSize(),o=this.getScrollOffset();if(t==="auto")if(e.end>=o+n-this.options.scrollPaddingEnd)t="end";else if(e.start<=o+this.options.scrollPaddingStart)t="start";else return[o,t];const r=t==="end"?e.end+this.options.scrollPaddingEnd:e.start-this.options.scrollPaddingStart;return[this.getOffsetForAlignment(r,t,e.size),t]},this.isDynamicMode=()=>this.elementsCache.size>0,this.scrollToOffset=(s,{align:t="start",behavior:e}={})=>{e==="smooth"&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."),this._scrollToOffset(this.getOffsetForAlignment(s,t),{adjustments:void 0,behavior:e})},this.scrollToIndex=(s,{align:t="auto",behavior:e}={})=>{e==="smooth"&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."),s=Math.max(0,Math.min(s,this.options.count-1));let n=0;const o=10,r=d=>{if(!this.targetWindow)return;const c=this.getOffsetForIndex(s,d);if(!c){console.warn("Failed to get offset for index:",s);return}const[u,h]=c;this._scrollToOffset(u,{adjustments:void 0,behavior:e}),this.targetWindow.requestAnimationFrame(()=>{const m=this.getScrollOffset(),g=this.getOffsetForIndex(s,h);if(!g){console.warn("Failed to get offset for index:",s);return}B(g[0],m)||a(h)})},a=d=>{this.targetWindow&&(n++,n<o?this.targetWindow.requestAnimationFrame(()=>r(d)):console.warn(`Failed to scroll to index ${s} after ${o} attempts.`))};r(t)},this.scrollBy=(s,{behavior:t}={})=>{t==="smooth"&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."),this._scrollToOffset(this.getScrollOffset()+s,{adjustments:void 0,behavior:t})},this.getTotalSize=()=>{var s;const t=this.getMeasurements();let e;if(t.length===0)e=this.options.paddingStart;else if(this.options.lanes===1)e=((s=t[t.length-1])==null?void 0:s.end)??0;else{const n=Array(this.options.lanes).fill(null);let o=t.length-1;for(;o>=0&&n.some(r=>r===null);){const r=t[o];n[r.lane]===null&&(n[r.lane]=r.end),o--}e=Math.max(...n.filter(r=>r!==null))}return Math.max(e-this.options.scrollMargin+this.options.paddingEnd,0)},this._scrollToOffset=(s,{adjustments:t,behavior:e})=>{this.options.scrollToFn(s,{behavior:e,adjustments:t},this)},this.measure=()=>{this.itemSizeCache=new Map,this.laneAssignments=new Map,this.notify(!1)},this.setOptions(l)}}const T=(i,l,s,t)=>{for(;i<=l;){const e=(i+l)/2|0,n=s(e);if(n<t)i=e+1;else if(n>t)l=e-1;else return e}return i>0?i-1:0};function X({measurements:i,outerSize:l,scrollOffset:s,lanes:t}){const e=i.length-1,n=a=>i[a].start;if(i.length<=t)return{startIndex:0,endIndex:e};let o=T(0,e,n,s),r=o;if(t===1)for(;r<e&&i[r].end<s+l;)r++;else if(t>1){const a=Array(t).fill(0);for(;r<e&&a.some(c=>c<s+l);){const c=i[r];a[c.lane]=c.end,r++}const d=Array(t).fill(s+l);for(;o>=0&&d.some(c=>c>=s);){const c=i[o];d[c.lane]=c.start,o--}o=Math.max(0,o-o%t),r=Math.min(e,r+(t-1-r%t))}return{startIndex:o,endIndex:r}}const A=typeof document<"u"?y.useLayoutEffect:y.useEffect;function G(i){const l=y.useReducer(()=>({}),{})[1],s={...i,onChange:(e,n)=>{var o;n?F.flushSync(l):l(),(o=i.onChange)==null||o.call(i,e,n)}},[t]=y.useState(()=>new K(s));return t.setOptions(s),A(()=>t._didMount(),[]),A(()=>t._willUpdate()),t}function Y(i){return G({observeElementRect:U,observeElementOffset:$,scrollToFn:H,...i})}function J(i,l){if(i.length===0)return l.length;if(l.length===0)return i.length;let s=Array(i.length+1).fill(0).map((e,n)=>n),t=Array(i.length+1);for(let e=1;e<=l.length;e++){t[0]=e;for(let n=1;n<=i.length;n++){const o=i[n-1]===l[e-1]?0:1;t[n]=Math.min(s[n]+1,t[n-1]+1,s[n-1]+o)}[s,t]=[t,s]}return s[i.length]}const Z=["all",...S],ee=["default","recent","expansion-newest"],te=N,se=["all","wanted","extra"];function ne(i,l,s){let t=k;if(i.deckbuildingMode&&(t=t.filter(e=>e.internal_id===e.alternate_versions[0])),i.expansion!==void 0&&i.expansion!=="all"&&(t=t.filter(e=>e.expansion===i.expansion)),i.expansion!==void 0&&i.pack!==void 0&&i.pack!=="all"&&(t=t.filter(e=>e.pack===i.pack||e.pack==="everypack")),i.trading!==void 0&&i.trading!=="all"){if(!s)throw new Error("Cannot filter by trading status without trading settings");const e=new Set(i.trading==="wanted"?L(l,s):R(l,s));t=t.filter(n=>e.has(n.internal_id))}if(i.sortBy!==void 0&&(i.sortBy==="recent"?t=t.toSorted((e,n)=>{const o=l.get(e.internal_id)?.updated_at,r=l.get(n.internal_id)?.updated_at;return o&&r?new Date(r).getTime()-new Date(o).getTime():o&&!r?-1:1}):i.sortBy==="expansion-newest"&&(t=[...t].sort((e,n)=>e.expansion!==n.expansion?S.indexOf(e.expansion)-S.indexOf(n.expansion):e.card_id.localeCompare(n.card_id,z.language||"en",{numeric:!0})))),t=t.filter(e=>i.rarity===void 0||i.rarity.length===0?!0:i.rarity.includes(e.rarity)),t=t.filter(e=>i.cardType===void 0||i.cardType.length===0?!0:e.card_type.toLowerCase()==="trainer"?i.cardType.includes("trainer"):i.cardType.includes(e.energy.toLowerCase())),i.search){const e=i.search.toLowerCase(),n=2;t=t.filter(o=>{const r=D(o,z.language).toLowerCase();let a=!1;i.allTextSearch&&(a=o.ability&&(o.ability.name.toLowerCase().includes(e)||o.ability.effect.toLowerCase().includes(e))||o.attacks.some(h=>h.name?.toLowerCase().includes(e)||h.effect?.toLowerCase()!=="no effect"&&h.effect?.toLowerCase()?.includes(e)));const d=r.includes(e),c=J(r,e)<=n,u=o.card_id.toLowerCase().includes(e);return a||d||c||u})}for(const e of t){i.deckbuildingMode?e.amount_owned=e.alternate_versions.reduce((o,r)=>{const a=W(r);return o+(l.get(a?.internal_id||0)?.amount_owned??0)},0):e.amount_owned=l.get(e.internal_id)?.amount_owned??0;const n=l.get(e.internal_id);e.collected=n?.collection.includes(e.card_id)??!1,e.updated_at=n?.updated_at}if(i.minNumber){const e=i.minNumber;t=t.filter(n=>(n.amount_owned??0)>=e)}if(i.maxNumber&&i.maxNumber!==100){const e=i.maxNumber;t=t.filter(n=>(n.amount_owned??0)<=e)}return t}export{te as c,Z as e,ne as g,ee as s,se as t,Y as u};
